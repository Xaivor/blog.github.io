import{_ as e,c as o,o as l,a2 as i}from"./chunks/framework.BTj4N_c1.js";const b=JSON.parse('{"title":"浏览器","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/browser.md","filePath":"knowledge/browser.md"}'),c={name:"knowledge/browser.md"},d=i('<h1 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h1><p>下面是常见的 <code>浏览器</code> 知识点：</p><h2 id="_1-页面加载过程及原理-⭐" tabindex="-1">1. 页面加载过程及原理 ⭐ <a class="header-anchor" href="#_1-页面加载过程及原理-⭐" aria-label="Permalink to &quot;1. 页面加载过程及原理 ⭐&quot;">​</a></h2><p>实际上就是问，从输入URL到页面展示，这中间发生了什么？</p><img src="https://img2.imgtp.com/2024/04/26/N7DIqJ83.png" width="100%"><ul><li><ol><li><code>解析地址</code>：浏览器根据输入的URL，解析出域名、端口、协议、路径、参数等。</li></ol></li><li><ol start="2"><li><code>DNS解析</code>：根据域名，查询对应的IP地址。</li></ol></li><li><ol start="3"><li><code>建立TCP连接</code>：浏览器根据IP地址，建立TCP连接。</li></ol></li><li><ol start="4"><li><code>发送HTTP请求</code>：请求指定的资源（涉及 3次握手）</li></ol></li><li><ol start="5"><li><code>服务器响应</code>：服务器处理来自浏览器的请求，这可能涉及到查询数据库、处理应用逻辑等。服务器生成一个HTTP响应并发送回浏览器。</li></ol></li><li><ol start="6"><li><code>解析HTTP响应</code>：浏览器根据HTTP响应，解析出HTML、CSS、JavaScript等资源。</li></ol></li><li><ol start="7"><li><code>渲染页面</code>：构建DOM树，构建渲染树，JS逻辑处理，布局，绘制，显示完成的页面。</li></ol></li></ul><blockquote><p>顶级理解：<a href="https://juejin.cn/post/7353535887492988938" target="_blank" rel="noreferrer">领悟页面加载原理，成为恋爱高手：一篇不可错过的对线指南</a></p></blockquote><h2 id="_2-前端缓存详解-⭐" tabindex="-1">2. 前端缓存详解 ⭐ <a class="header-anchor" href="#_2-前端缓存详解-⭐" aria-label="Permalink to &quot;2. 前端缓存详解 ⭐&quot;">​</a></h2><img src="https://img2.imgtp.com/2024/04/26/IC5HsbgA.png" width="100%"><h3 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h3><p><strong>强缓存</strong>：</p><ul><li><code>彻底缓存</code>，在缓存时间内不会向服务器发起请求，直接读取浏览器本地缓存，只有过期之后才会向服务器发起请求</li><li>状态码：<code>200</code></li><li>谁来决定：<code>浏览器</code></li><li>缓存强度：F5 刷新无效，Ctrl+F5 刷新清空</li><li>存放位置：<code>Disk Cache</code>（磁盘缓存）、<code>Memory Cache</code>（内存缓存）</li><li>判断缓存：由 <code>Expires</code> 、<code>Cache-Control</code> 、<code>Pragma</code> 这3个 Header 属性控制。</li></ul><p><strong>协商缓存</strong>：</p><ul><li>协商缓存都会向 <code>服务器</code> 发送请求，由 <code>服务器</code> 来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信。</li><li>状态码：<code>304</code></li><li>谁来决定：<code>服务器</code></li><li>缓存强度：F5 刷新和 Ctrl+F5 刷新都清空</li><li>判断缓存：由 <code>Last-Modified / If-Modified-Since</code>、<code>ETag / If-None-Match</code> 这2个 Header 成对属性 控制。</li></ul><h3 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h3><ul><li>默认缓存：<code>Bf Cache</code>，页面前进后退行为，会将浏览器DOM状态保存进该缓存。</li><li>本地缓存： <ul><li>WebStorage：大小跟浏览器相关，一般是 <code>5MB</code><ul><li><code>LocalStorage</code>：本地 <code>持久化</code> 存储，只能被 <code>显式清除</code>，数据 <code>可跨</code> 页面，跨浏览器</li><li><code>SessionStorage</code>：会话级别的 <code>临时</code> 存储，<code>关闭页面清除</code>，<code>不可跨</code> 页面，跨浏览器</li></ul></li><li><code>Cookie</code>：主要用于用户信息的存储，自动在请求的时候被传递给服务器，大小 <code>4KB</code></li><li><code>IndexDB</code>：客户端数据库，大小 <code>无限</code>。</li><li><code>WebSql</code>：提供 SQL 操作客户端数据库的 APIs</li><li>离线缓存： <ul><li><code>Application Cache</code>：静态资源缓存，h5的新特性</li><li><code>PWA</code>：基于App Manifest、Service Worker、Push Notification，实现的渐进式Web应用技术</li></ul></li></ul></li></ul><blockquote><p>顶级理解：<a href="https://juejin.cn/post/7352799449456918543" target="_blank" rel="noreferrer">前端缓存揭秘：5年前端技术的必备知识点</a></p></blockquote><h2 id="_3-浏览器跨域-⭐" tabindex="-1">3. 浏览器跨域 ⭐ <a class="header-anchor" href="#_3-浏览器跨域-⭐" aria-label="Permalink to &quot;3. 浏览器跨域 ⭐&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><ul><li>协议、域名、端口，只要有一个不同，就属于跨域</li><li>跨域条件： <ul><li><code>协议不同</code>（http 与 https）</li><li><code>域名不同</code>（baidu.com 与 google.com）</li><li><code>端口不同</code>（:8080 与 :80）</li></ul></li></ul><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ul><li><code>CORS</code>：跨源资源共享，在服务器端设置 <code>Access-Control-Allow-Origin</code> 等 HTTP 头部字段来告知浏览器哪些源可以访问该资源。（<code>后端处理</code>，常用解决方案一）。</li><li><code>JSONP</code>：JSONP 是一种利用 script 标签没有跨域限制的漏洞，通过动态创建 script 标签，设置其 src 属性为跨域 URL，然后执行该 URL 返回的 JavaScript 代码的一种跨域请求方式。不过，JSONP <code>只支持 GET 请求</code>。</li><li><code>Nginx</code> 反向代理：利用 Nginx 作为反向代理服务器，将前端的请求经过 Nginx 服务器转发到目标服务器，再将目标服务器返回的响应返回给前端。（<code>运维处理</code>，常用解决方案二）</li><li><code>WebSocket</code>：WebSocket 是一种基于 TCP 协议的全双工通信协议，可以实现客户端和服务器之间长时间的双向通信。由于 WebSocket 不受同源策略的限制，因此可以用于跨域通信。</li><li><code>postMessage</code>：window.postMessage 方法可以在不同窗口的文档中进行跨域通信。例如，在一个窗口中使用 postMessage 方法发送消息，然后在另一个窗口中监听 message 事件来接收消息。</li><li>设置 <code>document.domain</code>：对于主域相同但子域不同的跨域应用场景，可以通过设置相同的 document.domain 来使两个页面共享 Cookie，从而实现跨域通信。</li></ul>',22),a=[d];function t(r,s,n,h,u,p){return l(),o("div",null,a)}const g=e(c,[["render",t]]);export{b as __pageData,g as default};
