import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.BTj4N_c1.js";const u=JSON.parse('{"title":"React","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/react.md","filePath":"knowledge/react.md"}'),t={name:"knowledge/react.md"},l=e(`<h1 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h1><p>下面是常见的 <code>React</code> 知识点：</p><h2 id="_1-react-中的-fiber-架构-⭐" tabindex="-1">1. React 中的 Fiber 架构 ⭐ <a class="header-anchor" href="#_1-react-中的-fiber-架构-⭐" aria-label="Permalink to &quot;1. React 中的 Fiber 架构 ⭐&quot;">​</a></h2><p><code>Fiber</code> 架构是 <code>React</code> 16 引入的一种新的架构，它允许 <code>React</code> 在渲染过程中进行中断和恢复，从而实现更流畅的用户体验。</p><p>解决的痛点：</p><ul><li><code>增量渲染</code>：Fiber 架构可以将渲染工作拆分成多个时间片段执行，使得每个时间片段都有机会插入其他优先级更高的任务，从而在保证页面响应性的同时，尽可能快地完成渲染工作。</li><li><code>优先级调度</code>：Fiber 架构引入了任务优先级的概念，可以根据任务的紧急程度和重要性对任务进行优先级排序，确保优先级较高的任务能够尽早得到处理，提高用户交互的流畅度。</li><li><code>可中断和恢复</code>：Fiber 架构支持任务的中断和恢复，即在渲染过程中，如果有更高优先级的任务需要处理，当前任务可以被暂停并稍后恢复，以确保更及时地响应用户操作。</li><li><code>更好的错误处理</code>：Fiber 架构为错误处理提供了更好的机制。每个 Fiber 都有自己的错误边界，可以捕获并处理组件树中发生的错误，并在不崩溃整个应用程序的情况下进行优雅降级。</li></ul><h2 id="_2-react-中的-diff-算法-⭐" tabindex="-1">2. React 中的 Diff 算法 ⭐ <a class="header-anchor" href="#_2-react-中的-diff-算法-⭐" aria-label="Permalink to &quot;2. React 中的 Diff 算法 ⭐&quot;">​</a></h2><p><code>React Diff</code> 算法是 React 虚拟 Dom 的核心。它允许 React 快速确定虚拟 Dom 树上的哪些部分需要更新，从而使得 UI 更新非常的高效。</p><h3 id="同级比较" tabindex="-1">同级比较 <a class="header-anchor" href="#同级比较" aria-label="Permalink to &quot;同级比较&quot;">​</a></h3><ul><li>React 不会进行跨层级的 DOM 比较。它只比较同一层级的元素。</li></ul><h3 id="元素类型" tabindex="-1">元素类型 <a class="header-anchor" href="#元素类型" aria-label="Permalink to &quot;元素类型&quot;">​</a></h3><ul><li><strong>类型不同，删除重建</strong>：当两棵树的相同位置找到两个不同类型的元素时，React 会直接销毁旧节点及其子节点，并从头开始创建新节点。</li><li><strong>类型相同，复用节点</strong>：如果两个元素是相同类型的，React 会保留该 DOM 节点，并仅更新变化的属性。并递归地对其子节点进行比较。</li></ul><h3 id="keys重要性" tabindex="-1">Keys重要性 <a class="header-anchor" href="#keys重要性" aria-label="Permalink to &quot;Keys重要性&quot;">​</a></h3><p>当在数组中渲染子节点时，必须为每个子节点分配一个稳定的 Key 值。通过为每个节点分配一个 Key，React 可以使用这个 Key 来识别那些在不同的渲染中仍然保持不变的元素。</p><blockquote><p>如果你没有设置 Key，React 内部会默认使用元素的索引作为它们的 Key</p><p><code>若是设置一个随机 Key 会怎样</code>？</p></blockquote><p><strong>现象</strong>：每次组件渲染，随机 Key 值都会变化，即时实际渲染的数据没有变，这个元素也会被销毁重新创建。</p><p>这将导致以下问题出现：</p><ol><li>性能下降</li><li>状态丢失 <ul><li>如果一个组件或元素依赖于本地状态或维护状态（如输入字段）。</li></ul></li><li>不一致的 DOM 行为 <ul><li>这可能导致不可预测的行为，如焦点丢失、文本选择丢失等。</li></ul></li></ol><h2 id="_3-react-中的-virtual-dom-⭐" tabindex="-1">3. React 中的 Virtual DOM ⭐ <a class="header-anchor" href="#_3-react-中的-virtual-dom-⭐" aria-label="Permalink to &quot;3. React 中的 Virtual DOM ⭐&quot;">​</a></h2><p>虚拟 DOM 本质上是一个 JS 对象，它反映了真实 DOM 的结构和内容。</p><ul><li>1.提供一个中间缓存，使得直接操作实际的 DOM（这通常是昂贵的操作）不再那么频繁。</li><li>2.通过对比新旧虚拟 DOM 来计算出最小的变动，从而优化实际 DOM 的更新。</li></ul><p>虚拟 DOM 可以让 React 更优雅高效的更新真实 DOM，虚拟 DOM 可以让开发者不用关注 DOM 操作，只操作数据。</p><h2 id="_4-react-中的-hooks-⭐" tabindex="-1">4. React 中的 Hooks ⭐ <a class="header-anchor" href="#_4-react-中的-hooks-⭐" aria-label="Permalink to &quot;4. React 中的 Hooks ⭐&quot;">​</a></h2><p><code>Hooks</code> 是 React 16.8 版本引入的新特性，它允许在函数组件中使用状态（state）和生命周期（lifecycle）等 React 特性。</p><h3 id="常用-hooks" tabindex="-1">常用 Hooks <a class="header-anchor" href="#常用-hooks" aria-label="Permalink to &quot;常用 Hooks&quot;">​</a></h3><ul><li><code>useState</code>：用于在函数组件中定义和更新状态（state）。</li><li><code>useEffect</code>：用于在函数组件中执行副作用操作（side effect）。</li><li><code>useContext</code>：用于在函数组件中获取上下文（context）的值。</li><li><code>useReducer</code>：用于在函数组件中实现状态管理。</li><li><code>useRef</code>：用于在函数组件中获取对 DOM 元素的引用。</li><li><code>useCallback</code>：用于在函数组件中缓存函数。</li><li><code>useMemo</code>：用于在函数组件中缓存计算结果。</li><li><code>useLayoutEffect</code>：类似于 <code>useEffect</code>，但会在 DOM 更新后同步调用副作用函数。</li></ul><h2 id="_5-react-中的-生命周期-⭐" tabindex="-1">5. React 中的 生命周期 ⭐ <a class="header-anchor" href="#_5-react-中的-生命周期-⭐" aria-label="Permalink to &quot;5. React 中的 生命周期 ⭐&quot;">​</a></h2><p>React 组件的生命周期是指组件从创建到销毁的过程，它包括三个阶段：<code>挂载</code>、<code>更新</code>和<code>卸载</code>。</p><ul><li><code>挂载</code>：组件创建时，会调用 <code>constructor</code> 方法，然后调用 <code>render</code> 方法，最后调用 <code>componentDidMount</code> 方法。</li><li><code>更新</code>：当组件的 <code>props</code> 或 <code>state</code> 发生变化时，会调用 <code>render</code> 方法，然后调用 <code>componentDidUpdate</code> 方法。</li><li><code>卸载</code>：当组件从 DOM 中移除时，会调用 <code>componentWillUnmount</code> 方法。</li></ul><h3 id="挂载阶段" tabindex="-1">挂载阶段 <a class="header-anchor" href="#挂载阶段" aria-label="Permalink to &quot;挂载阶段&quot;">​</a></h3><ul><li><code>constructor</code>：在组件创建时调用，用于初始化组件的状态。</li><li><code>render</code>：在组件创建时调用，用于返回组件的 UI 结构。</li><li><code>componentDidMount</code>：在组件挂载后调用，用于执行一些副作用操作，如发送网络请求、订阅事件等。</li></ul><h3 id="更新阶段" tabindex="-1">更新阶段 <a class="header-anchor" href="#更新阶段" aria-label="Permalink to &quot;更新阶段&quot;">​</a></h3><ul><li><code>componentWillReceiveProps</code>：在组件接收到新的 <code>props</code> 时调用，用于更新组件的状态。</li><li><code>shouldComponentUpdate</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 时调用，用于判断是否需要重新渲染组件。</li><li><code>componentWillUpdate</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 且 <code>shouldComponentUpdate</code> 返回 <code>true</code> 时调用，用于更新组件的状态。</li><li><code>render</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 时调用，用于返回组件的 UI 结构。</li><li><code>componentDidUpdate</code>：在组件更新后调用，用于执行一些副作用操作，如发送网络请求、订阅事件等。</li></ul><h3 id="卸载阶段" tabindex="-1">卸载阶段 <a class="header-anchor" href="#卸载阶段" aria-label="Permalink to &quot;卸载阶段&quot;">​</a></h3><ul><li><code>componentWillUnmount</code>：在组件从 DOM 中移除时调用，用于执行一些清理操作，如取消订阅事件、清除定时器等。</li></ul><h2 id="_6-usememo、react-memo、usecallback区别-⭐" tabindex="-1">6. useMemo、React.memo、useCallback区别 ⭐ <a class="header-anchor" href="#_6-usememo、react-memo、usecallback区别-⭐" aria-label="Permalink to &quot;6. useMemo、React.memo、useCallback区别 ⭐&quot;">​</a></h2><p><code>useMemo</code> 和 <code>React.memo</code> 都是 React 中的性能优化工具，但它们的作用和用法上有些区别。</p><ul><li><code>useMemo</code>：用于在组件渲染时计算某个值，并将计算结果缓存起来，避免在每次渲染时重新计算。</li><li><code>React.memo</code>：用于优化组件的渲染，当组件的 props 没有变化时，避免重新渲染。</li><li><code>useCallback</code>：用于在组件渲染时缓存某个函数，避免在每次渲染时重新创建函数。</li></ul><h2 id="_7-usestate-和-useref-区别-⭐" tabindex="-1">7. useState 和 useRef 区别 ⭐ <a class="header-anchor" href="#_7-usestate-和-useref-区别-⭐" aria-label="Permalink to &quot;7. useState 和 useRef 区别 ⭐&quot;">​</a></h2><ul><li>触发渲染：<code>useState</code> 更新状态时会触发组件的重新渲染，而 <code>useRef</code> 更新 <code>.current</code> 属性时不会。</li><li>用途：<code>useState</code> 用于那些组件状态（通常是用户界面状态），这些状态的改变需要导致组件重新渲染。<code>useRef</code> 用于持久化存储数据，这些数据的改变不应该引起渲染。</li><li>返回值：<code>useState</code> 返回一个状态值和一个更新这个状态值的函数。<code>useRef</code> 返回一个具有 <code>.current</code> 属性的对象，你可以在其中存储任何值。</li></ul><h2 id="_8-useeffect-和-uselayouteffect-⭐" tabindex="-1">8. useEffect 和 useLayoutEffect ⭐ <a class="header-anchor" href="#_8-useeffect-和-uselayouteffect-⭐" aria-label="Permalink to &quot;8. useEffect 和 useLayoutEffect ⭐&quot;">​</a></h2><h3 id="useeffect" tabindex="-1">useEffect <a class="header-anchor" href="#useeffect" aria-label="Permalink to &quot;useEffect&quot;">​</a></h3><ul><li>作用：<code>useEffect</code> 允许你执行任何在组件渲染后需要执行的操作。这些副作用包括数据获取、订阅或手动更改 React 组件树之外的 DOM。</li><li>执行时机：<code>useEffect</code> 在组件渲染到屏幕之后被调用，因此不会阻塞 DOM 的更新。这对于大多数副作用是合适的，尤其是那些不需要同步到屏幕的操作。</li><li>示例用途：数据请求、设置订阅、以及任何需要在组件加载后执行且不需要立即反映在屏幕上的操作。</li></ul><h3 id="uselayouteffect" tabindex="-1">useLayoutEffect <a class="header-anchor" href="#uselayouteffect" aria-label="Permalink to &quot;useLayoutEffect&quot;">​</a></h3><ul><li>作用：<code>useLayoutEffect</code> 的使用和 <code>useEffect</code> 相似，但它在 DOM 更新完成后、浏览器绘制之前同步调用。这使得它可以读取 DOM 布局并同步重新渲染。</li><li>执行时机：<code>useLayoutEffect</code> 会在 DOM 更新后立即同步执行，但在浏览器进行任何绘制之前，这意味着你可以在浏览器绘制之前读取布局并同步更新它，避免不必要的视觉闪烁。</li><li>示例用途：用于需要同步计算和重新渲染的操作，例如测量 DOM 节点的布局、同步动画等。</li></ul><h2 id="_9-类组件-和-函数组件-⭐" tabindex="-1">9. 类组件 和 函数组件 ⭐ <a class="header-anchor" href="#_9-类组件-和-函数组件-⭐" aria-label="Permalink to &quot;9. 类组件 和 函数组件 ⭐&quot;">​</a></h2><p>React一开始，以类组件作为主体，在React16.8版本（引入React Hooks）后，解决了类组件的部分痛点（Hooks部分再说明），函数组件后来者居上。</p><h3 id="类组件" tabindex="-1">类组件 <a class="header-anchor" href="#类组件" aria-label="Permalink to &quot;类组件&quot;">​</a></h3><p><strong>定义特点</strong>：</p><ul><li>组件首字母大写</li><li>继承自 React.Component</li><li>必须实现render函数</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用ES6 Class语法</li><li>构造器是可选的，用于初始化数据</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { Component } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;我是类组件&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="函数组件" tabindex="-1">函数组件 <a class="header-anchor" href="#函数组件" aria-label="Permalink to &quot;函数组件&quot;">​</a></h3><p>函数组件，字面意思，就是JavaSript函数作为React组件。</p><p><strong>定义特点</strong>：</p><ul><li>组件首字母大写</li><li>无生命周期函数，可用useEffect替代</li><li>无状态管理，可用useState替代</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个函数组件  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用JSX来渲染组件的UI  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Hello, {name}!  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在另一个组件或应用中使用Greeting组件  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Greeting</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Greeting</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App;</span></span></code></pre></div><h2 id="_10-高阶组件-⭐" tabindex="-1">10. 高阶组件 ⭐ <a class="header-anchor" href="#_10-高阶组件-⭐" aria-label="Permalink to &quot;10. 高阶组件 ⭐&quot;">​</a></h2><ul><li><strong>定义</strong>：高阶组件（HOC）是一个函数，接收一个组件作为参数，返回一个新的组件。</li><li>应用场景： <ul><li><strong>复用逻辑</strong>：高阶组件可以帮助我们在组件之间复用逻辑，避免重复代码。如果你现在多个组件有相同的逻辑代码，你可以将这个逻辑抽离出来封装一个高阶组件，实现代码逻辑的复用。</li><li><strong>加工 props</strong>：高阶组件可以加工传递给组件的 props，从而改变组件的行为。</li><li><strong>条件渲染</strong>：高阶组件可以根据特定的条件来决定是否渲染组件。</li><li><strong>提供额外功能</strong>：高阶组件可以增强现有组件的功能，如错误处理，数据获取等等。</li></ul></li></ul><h2 id="_11-受控组件-和-非受控组件-⭐" tabindex="-1">11. 受控组件 和 非受控组件 ⭐ <a class="header-anchor" href="#_11-受控组件-和-非受控组件-⭐" aria-label="Permalink to &quot;11. 受控组件 和 非受控组件 ⭐&quot;">​</a></h2><h3 id="受控组件" tabindex="-1">受控组件 <a class="header-anchor" href="#受控组件" aria-label="Permalink to &quot;受控组件&quot;">​</a></h3><ul><li><p><strong>定义</strong>：受控组件是指通过 <code>React</code> 的 <code>state</code> 来控制组件的输入。每当表单数据改变时，都会通过一个事件处理函数来更新 <code>state</code>，然后组件会根据这个新的 <code>state</code> 来重新渲染。</p></li><li><p><strong>特点</strong>：</p><ul><li><code>数据驱动</code>：组件的状态完全由 <code>React</code> 的 <code>state</code> 和 <code>props</code> 控制。</li><li><code>即时更新</code>：每个状态的改变都伴随着组件的重新渲染。</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ControlledComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.target.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{value} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleChange} /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h3 id="非受控组件" tabindex="-1">非受控组件 <a class="header-anchor" href="#非受控组件" aria-label="Permalink to &quot;非受控组件&quot;">​</a></h3><ul><li><p><strong>定义</strong>：非受控组件是指通过 <code>DOM</code> 的 <code>ref</code> 来控制组件的输入。非受控组件通过 <code>DOM</code> 的 <code>ref</code> 来获取组件的输入，而不是通过 <code>React</code> 的 <code>state</code> 来控制组件的输入。</p></li><li><p><strong>特点</strong>：</p><ul><li><code>DOM</code> 驱动：表单数据由 <code>DOM</code> 节点自己管理，<code>React</code> 不负责维护状态。</li><li>使用 <code>ref</code> 访问：通常通过 <code>ref</code> 来从 <code>DOM</code> 节点获取表单数据。</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useRef } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UncontrolledComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A name was submitted: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputRef.current.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleSubmit}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputRef} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;submit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Submit&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h3 id="对比" tabindex="-1">对比 <a class="header-anchor" href="#对比" aria-label="Permalink to &quot;对比&quot;">​</a></h3><table><thead><tr><th>组件类型</th><th>数据管理</th><th>更新方式</th><th>使用场景</th></tr></thead><tbody><tr><td><code>受控</code> 组件</td><td>由 <code>React</code> 管理</td><td><code>state</code> 和 <code>props</code> 实时更新</td><td>实时验证，控制 <code>输入</code></td></tr><tr><td><code>非受控</code> 组件</td><td>由 <code>DOM</code> 管理</td><td>依赖 <code>ref</code> 获取当前值</td><td>表单提交，<code>取值</code></td></tr></tbody></table><blockquote><p>总结：<code>React</code> 推荐使用受控组件来实现表单，因为需要控制组件的状态和行为。但非受控组件在一些场景下（例如性能要求极高）可能更为简单。</p></blockquote><h2 id="_12-react-18-的新特性-⭐" tabindex="-1">12. React 18 的新特性 ⭐ <a class="header-anchor" href="#_12-react-18-的新特性-⭐" aria-label="Permalink to &quot;12. React 18 的新特性 ⭐&quot;">​</a></h2><blockquote><p><a href="https://zh-hans.react.dev/blog/2022/03/29/react-v18" target="_blank" rel="noreferrer">官方文档：React v18.0 的新特性</a></p></blockquote><h3 id="concurrent-mode-并发模式" tabindex="-1">Concurrent Mode（并发模式） <a class="header-anchor" href="#concurrent-mode-并发模式" aria-label="Permalink to &quot;Concurrent Mode（并发模式）&quot;">​</a></h3><p><code>Concurrent Mode</code> 是一种新的渲染模式，它允许 <code>React</code> 在主线程上执行渲染操作，从而提高应用程序的性能和响应能力。</p><p>在 <code>React18</code> 之前，所有任务都被视为急迫任务，<code>react18</code> 引入了并发模式，在这个模式下，渲染是可以中断的，高优先级的任务可以优先渲染更新。开启并发模式只需要将之前的 <code>ReactDom.render</code> 换成 <code>ReactDom.createRoot</code> 这个新的 <code>api</code> 即可。</p><h3 id="自动批量处理" tabindex="-1">自动批量处理 <a class="header-anchor" href="#自动批量处理" aria-label="Permalink to &quot;自动批量处理&quot;">​</a></h3><p>在 <code>React18</code> 之前，我们只在 <code>React</code> 事件处理函数 中进行批处理更新。默认情况下，在 <code>promise</code>、<code>setTimeout</code>、原生事件处理函数中、或任何其它事件内的更新都不会进行批处理。<code>React18</code> 之后，默认自动执行批处理，多次更新合并为一次更新。</p><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><ul><li>新的 Suspense 特性：允许在组件中使用异步组件，从而实现组件的懒加载和错误边界处理。</li><li>新的 Hooks：<code>useId</code>、 <code>useTransition</code>、 <code>useDeferredValue</code>、 <code>useSyncExternalStore</code>、 <code>useInsertionEffect</code></li><li>新的 根节点挂载方式：使用新的 <code>API createRoot</code> 来替代旧的 <code>render</code> 方法。</li></ul><h2 id="_13-react-vue-异同处-⭐" tabindex="-1">13. React Vue 异同处 ⭐ <a class="header-anchor" href="#_13-react-vue-异同处-⭐" aria-label="Permalink to &quot;13. React Vue 异同处 ⭐&quot;">​</a></h2><h3 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ul><li>都有 虚拟 <code>Dom + Diff</code> 算法 的渲染机制，用于提升渲染速度</li><li>都使用 组件化开发，通过 <code>props</code> 传参等方式进行父子数据通信</li><li>都具备 状态管理（ <code>Vue</code> 的 <code>Vuex/Pinia</code>，<code>React</code>的 <code>Redux/Mobx</code> ）</li><li>都支持 跨平台开发（ <code>Vue</code> 的 <code>Uniapp</code>， <code>React</code> 的 <code>React Native</code> ）</li></ul><h3 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点&quot;">​</a></h3><p><strong>1.框架层面</strong>：</p><p><code>Vue</code>：</p><ul><li>本质属于 MVVM 模式（由 MVC 发展出来的）</li><li>由于 MVVM 模式，<code>双向数据流</code></li></ul><p><code>React</code>：</p><ul><li>严格意义上，只能算是 MVC 中的 View 层</li><li>由于 MVC 模式，<code>单向数据流</code></li></ul><p><strong>2.数据层面</strong>：</p><p><code>Vue</code>：</p><ul><li>vue 推崇 <code>响应式</code>，实现了数据的 <code>双向绑定</code>。</li><li>由于数据可变，当数据发生变化，可通过 getter/setter 以及一些 函数的 <code>劫持监听数据的变化</code></li><li>并且当数据变化时，可直接更新到对应的虚拟 Dom（VM 的理念）</li></ul><p>React：</p><ul><li>React 推崇 <code>不可变（Immutable）</code>，为 <code>单向数据流</code>。</li><li>由于数据不可变，所以 React 无需监听数据的变化，React 只对 <code>setState</code> 之后会有 <code>重新渲染</code> 的流程</li><li>当数据发生变化（ setState 之后），React 默认是通过 <code>比较引用的方式（Diff） 进行的</code>，所以若是不优化，则会导致大量非必要渲染，从而影响性能（代码要求更高）</li></ul><p><strong>3.渲染层面</strong>：</p><p><code>Vue</code>：</p><ul><li>Vue 可以很快的计算出虚拟 DOM 的差异，这由于它监听了每一个组件的依赖关系，<code>不需要重新渲染整个组件树</code></li></ul><p><code>React</code>：</p><ul><li>React 数据变化时，<code>会将全部子组件重新渲染</code>。但可 shouldComponentUpdate 这个生命周期函数进行控制。</li></ul><p><strong>4.Diff 算法</strong>：</p><p><code>Vue</code>：</p><ul><li><code>同层比较新老</code>：新的不存在旧的存在就删除，新的存在旧的不存在就创建</li><li>基于 Snabbdom 库，使用<code>双向链表，边对比，边更新 DOM</code>。</li></ul><p><code>React</code>：</p><ul><li><code>递归同层比较</code>，标识差异点保存到 Diff 队列，从而得到 patch 树，再 <code>统一操作批量更新</code> DOM。</li></ul><p><strong>5.其他层面</strong>：</p><ul><li>模板语法不同：Vue 是 <code>指令+模板语法</code>，react 是 <code>函数式编程</code></li><li>性能优化可控：Vue 性能优化（自动的）相对 React 可控性低，因此大型应用，数据量庞大，无需过量非必要的 Watcher，出于性能方面，推荐使用可控的 React。</li><li>社区生态差异：Vue 国内受众人群多，React 国际受众人群多（更为成熟↑）</li></ul><h2 id="_14-react-中的-组件通信-⭐" tabindex="-1">14. React 中的 组件通信 ⭐ <a class="header-anchor" href="#_14-react-中的-组件通信-⭐" aria-label="Permalink to &quot;14. React 中的 组件通信 ⭐&quot;">​</a></h2><h3 id="props" tabindex="-1">Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;Props&quot;">​</a></h3><p>最基本的通信方式，适用于简单的父子关系，单向传递。</p><h3 id="state" tabindex="-1">State <a class="header-anchor" href="#state" aria-label="Permalink to &quot;State&quot;">​</a></h3><p>使用 React 的内置 Hook <code>useState</code> 或 <code>useReducer</code>，来更复杂的状态管理。</p><h3 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h3><p>跨层级组件通信，创建 Context 对象，在父组件中使用 <code>&lt;Context.Provider&gt;</code> 包裹需要共享数据的子组件，然后在子组件中使用 <code>&lt;Context.Consumer&gt;</code> 或 <code>useContext</code> Hook 来访问这些数据。</p><h3 id="事件回调函数" tabindex="-1">事件回调函数 <a class="header-anchor" href="#事件回调函数" aria-label="Permalink to &quot;事件回调函数&quot;">​</a></h3><ul><li>子组件可以通过回调函数（作为 props 传递）来通知父组件某些事件或状态的变化。</li><li>父组件可以定义这些回调函数，并在子组件触发事件时执行相应的逻辑</li></ul><h3 id="redux" tabindex="-1">Redux <a class="header-anchor" href="#redux" aria-label="Permalink to &quot;Redux&quot;">​</a></h3><ul><li>对于更复杂的应用，可能需要使用 <code>Redux</code> 这样的状态管理库。</li><li><code>Redux</code> 提供了一种集中的方式来存储和管理应用的状态，并提供了一套可预测的状态更新机制。</li><li>通过 <code>Redux</code>，组件可以通过 <code>action</code> 来触发状态的更新，并通过 <code>selector</code> 来获取状态数据。</li></ul><h3 id="其他库和框架" tabindex="-1">其他库和框架 <a class="header-anchor" href="#其他库和框架" aria-label="Permalink to &quot;其他库和框架&quot;">​</a></h3><ul><li>MobX、Zustand 等其他状态管理的插件。</li></ul><h2 id="_15-redux-状态管理库-⭐" tabindex="-1">15. Redux 状态管理库 ⭐ <a class="header-anchor" href="#_15-redux-状态管理库-⭐" aria-label="Permalink to &quot;15. Redux 状态管理库 ⭐&quot;">​</a></h2><p><code>Redux</code> 是 <code>react</code> 的一个状态管理库。</p><p><code>Redux</code> 的三大原则：</p><ul><li>1.单一数据源：应用的状态存储在唯一的 <code>store</code> 中。</li><li>2.状态是只读的：唯一改变状态的方式是触发 <code>action</code>。</li><li>3.使用纯函数执行修改：为了指定 <code>action</code> 如何改变状态，你需要编写 <code>reducers</code>。</li></ul><p>常用概念：</p><ul><li><code>Actions</code>：描述发生了什么的对象。</li><li><code>Reducers</code>：指定每个 <code>action</code> 如何改变应用状态的函数。</li><li><code>Store</code>：将 <code>Actions</code> 和 <code>Reducers</code> 绑定在一起的对象。</li></ul><blockquote><p>Redux 通过解耦状态和 UI，使得状态管理更加明确和可预测。但也因为其模式和约束，对于一些简单的应用，使用 Redux 可能会显得过于复杂。不过，在大型应用和复杂状态管理场景下，Redux 的优势就显现出来了。</p></blockquote>`,123),n=[l];function h(o,d,c,p,k,r){return a(),i("div",null,n)}const g=s(t,[["render",h]]);export{u as __pageData,g as default};
